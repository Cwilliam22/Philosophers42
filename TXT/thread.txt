Thread
Utilise pour booster les performances d'un programme.
On repartit diffrentes taches entre differents thread pour etre plus efficace.
Un bon programme doit etre multi thread s'il veut etre rapide/performant/bon.

Les threads d‚Äôun m√™me processus partagent le m√™me espace m√©moire 
(contrairement aux processus, qui ont chacun leur propre m√©moire s√©par√©e).

Cela permet aux threads de s‚Äô√©changer des donn√©es facilement et d‚Äôacc√©der aux 
m√™mes variables/m√©moire sans co√ªt suppl√©mentaire (puisqu‚Äôils sont dans le m√™me 
espace m√©moire).

L‚ÄôIPC (communication entre processus) est donc beaucoup plus simple entre threads,
parce qu‚Äôils peuvent acc√©der directement aux m√™mes donn√©es.

Mais ! Le probl√®me compliqu√©, ce n‚Äôest pas de partager les donn√©es, c‚Äôest de
synchroniser correctement les acc√®s pour √©viter les conflits (conditions de
course, incoh√©rences, etc.).

Exemple :
Une personne pour tenir un restaurant est moins efficace qu'une equipe avec
chacun une tache assigne.

Un thread fonctionne comme un micro-process dans le process lui-meme.

Preparer la mise en place des thread dans notre programme en C :

#include <pthread.h>

Pour creer un thread :
	pthread_t my_thread;
		-> pthread_t est generalement un unsigned long
	int status = pthread_create(&my_thread, NULL, my_function, NULL);

Chaque thread a un identifiant unique.
Important pour manager les threads.
pthread_t represents the ID of a thread in UNIX-like systems.

---------------------------------EXEMPLE-----------------------------------
	#include <stdio.h>
	#include <pthread.h>

	void *print_thread_id(void *tid) 
	{
		printf("Thread ID: %lu\n", *(pthread_t *)tid);
		return NULL;
	}

	int main() {
		pthread_t thread1, thread2;
		pthread_create(&thread1, NULL, print_thread_id, &thread1);
		pthread_create(&thread2, NULL, print_thread_id, &thread2);

		pthread_join(thread1, NULL);
		pthread_join(thread2, NULL);

	}
---------------------------------------------------------------------------
Fonction pthread_create() :

int pthread_create(pthread_t *thread,
				   const pthread_attr_t *attr,
				   void *(*start_routine)(void *),
				   void *arg);

pthread_t *thread : pointeur vers un identifiant de thread
	-> l'ID du thread
const pthread_attr_t *attr : attributs du thread
	-> g√©n√©ralement NULL (valeurs par d√©faut)
void *(*start_routine)(void *) : pointeur vers la fonction du thread
	-> fonction qui sera ex√©cuter par le thread
void *arg : argument √† passer √† start_routine

√Ä quoi sert la fonction pthread_creat() ???
-> Sert √† cr√©er/d√©marrer un nouveau thread dans le programme

Fonction pthread_join() :

int pthread_join(pthread_t thread, void **retval);

pthread_t thread : identifiant du thread
void **retval : pointeur vers la valeur de retour du thread	

√Ä quoi sert la fonction pthread_join() ???
-> Attend que le thread cibl√© par thread finisse son ex√©cution
-> Optionnellement r√©cup√®re ce que le thread a retourn√© via return (un void *)
-> Bloque le thread appelant (souvent main()) jusqu‚Äô√† ce que l‚Äôautre thread soit termin√©
-> Nettoie automatiquement les ressources du thread (√©quivalent d‚Äôun free de thread)

Ces deux fonctions utilisent le ID pour manager ces thread.

On peut obtenir la l'ID en utilisant la fonction pthread_self().

Fonction pthread_self() :


---------------------------------EXEMPLE-----------------------------------

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

void *make_coffee(void *arg)
{
 printf("Making coffee...\n");
 sleep(2);
 printf("Coffee ready!\n");
 return (NULL);
}

void *make_pastry(void *arg)
{
 printf("Baking pastry...\n");
 sleep(3);
 printf("Pastry ready!\n");
 return (NULL);
}

int main(void)
{
 pthread_t coffee_thread;
 pthread_t pastry_thread;

 pthread_create(&coffee_thread, NULL, make_coffee, NULL);
 pthread_create(&pastry_thread, NULL, make_pastry, NULL);
 
 //Before handing the order to customer, i nees to WAIT both threads
 pthread_join(coffee_thread, NULL);
 pthread_join(pastry_thread, NULL);
 
 printf("\n\n\tThx for coming to Starbucks!\n"
	 "\there's the ‚òïÔ∏è 'n ü•ê\n\n\n");
 return (0);
}
---------------------------------------------------------------------------

Thread = une ¬´ mini-ex√©cution ¬ª √† l‚Äôint√©rieur d‚Äôun processus, qui peut tourner 
en parall√®le avec d‚Äôautres threads.
Chaque thread a une fonction d‚Äôentr√©e (comme un main pour lui tout seul).
	
	pthread_create(...) -> permet de cr√©er un thread.
	
	Arguments
	- Une variable de type pthread_t (l‚Äôidentifiant du thread),
	- Des options (souvent NULL),
	- La fonction que le thread ex√©cutera,
	- Un argument pour cette fonction (ou NULL).

	pthread_t = identifiant du thread (opaque, ne pas supposer que c‚Äôest un simple 
	unsigned long, m√™me si c‚Äôest souvent le cas).

	pthread_self() = permet √† un thread de conna√Ætre son propre ID.

	pthread_join(thread, NULL) = dit au programme : ¬´ Attend que ce thread finisse avant de continuer ¬ª.
		-> C‚Äôest l‚Äô√©quivalent de wait() mais pour les threads.
		-> Ce n‚Äôest pas un outil pour d√©finir l‚Äôordre d‚Äôex√©cution, juste un moyen 
		de synchroniser et s‚Äôassurer qu‚Äôun thread est termin√© avant de passer √† la suite.
		-> pthread_join() n‚Äôinfluence pas la priorit√© ni l‚Äôordre d‚Äôex√©cution des threads.
		-> outils de synchronisation

Dans l'exemple, comme les t√¢ches sont tr√®s simples et seulement diff√©renci√©es par un sleep, 
celui qui dort moins finira avant et donc son printf sortira plus t√¥t.

Mais dans un vrai programme, le temps de fin d√©pendra :

	- de la charge CPU
	- de l‚ÄôOS
	- du moment o√π le thread est planifi√©
	- du code qu‚Äôil ex√©cute

---------------------------------EXEMPLE-----------------------------------

#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int x = 42;
int main()
{
	pid_t pid = fork(); // Creates a new process
  // child
	if (0 == pid)
	{
		x++;
		printf("Child process: Value of x = %d\\n", x);
	}
  //parent
	else
	{
		wait(NULL); // Wait for child to finish
		printf("Parent process: Value of x = %d\\n", x);
	}
}
---------------------------------------------------------------------------

Resultat : 
Child process: Value of x = 43
Parent process: Value of x = 42


---------------------------------EXEMPLE-----------------------------------

#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

int x = 42;
void *thread_task(void *arg)
{
	++x;
	printf("Thread: Value of x = %d\\n", x);
	return NULL;
}
int main()
{
	pthread_t thread1, thread2;
	pthread_create(&thread1, NULL, thread_task, NULL);
	pthread_create(&thread2, NULL, thread_task, NULL);
	pthread_join(thread1, NULL);
	pthread_join(thread2, NULL);
	return 0;
}

---------------------------------------------------------------------------

Resultat :
Thread: Value of x = 43
Thread: Value of x = 44

Deux exemples qui montre la difference entre les process et les threads.
Les process fonctionenent chacun de leur cote (leur propre data, leur propre memoire, etc).
Les thread partage tout !!!

Sur la memoire :
	(Processus)
		- A sa propre m√©moire isol√©e (code, donn√©es, pile).
		- Les variables globales ne sont pas partag√©es entre processus.
		- Si un processus fils modifie une variable, le p√®re ne le voit pas.
		- Exemple : fork() ‚Üí le p√®re et le fils ont chacun leur copie de x.

	(Threads)
		- Partagent le m√™me espace m√©moire dans un processus.
		- Les variables globales sont communes √† tous les threads.
		- Si un thread modifie x, tous les autres voient le changement.

Sur l'ID et le PID:
	Chaque process a un PID unique.
	Tout les threads dans un process partagent le meme PID.
		-> Chaque process possede aussi son propre ID.

---------------------------------EXEMPLE-----------------------------------

#include <pthread.h>
#include <unistd.h>
#include <stdio.h>

// This function represents the routine (task) our workers (threads) will execute.
void *worker_routine(void *arg)
{
	// All workers (threads) inside the factory (process) will print the same address (PID)
	printf("Worker ID->%lu: My factory's address (PID) is %d\\n", pthread_self(), getpid());
	return (NULL);
}
int main(void)
{
	pthread_t worker1;
	pthread_t worker2;
	// Let's create two workers (threads) in the same factory (process).
	// Hiring (creating) the first worker.
	if (pthread_create(&worker1, NULL, worker_routine, NULL) != 0)
		return (1);
	// Hiring (creating) the second worker.
	if (pthread_create(&worker2, NULL, worker_routine, NULL) != 0)
		return (2);
	// Wait for both workers to finish their shift (tasks).
	pthread_join(worker1, NULL);
	pthread_join(worker2, NULL);
	return (0);
}

---------------------------------------------------------------------------

Sur la communication :

	(Processus)
		- N√©cessite des m√©canismes sp√©ciaux (IPC) : pipes, sockets, m√©moire partag√©e.
	(Threads)
		- Communication simple car m√™me m√©moire.
		- Risque de corruption de donn√©es si acc√®s simultan√© non contr√¥l√© ‚Üí mutex/semaphores 
		obligatoires pour √©viter les race conditions.

Race Condition : 

(Probl√®me)
Une race condition arrive quand plusieurs threads (ou processus) acc√®dent en m√™me temps 
√† une ressource partag√©e et au moins un d‚Äôeux la modifie, sans m√©canisme pour coordonner 
cet acc√®s.

En somme nous pouvons avoir √† faire √† des op√©rations qui se marchent dessus ou √† des donn√©es
qui peuvent √™tre incoh√©rente voir m√™me perdues.

(L‚Äôanalogie Starbucks)
Imagine un registre (le ledger) qui contient le nombre total de boissons servies.

Plusieurs serveurs (threads) mettent √† jour ce registre en m√™me temps :
	1. Ils lisent la valeur (ex : 42 boissons).
	2. Ils retiennent ce nombre dans leur t√™te (registre CPU).
	3. Ils servent une boisson.
	4. Ils √©crivent la nouvelle valeur (ancienne valeur + 1) dans le registre.

Si deux serveurs lisent "42" en m√™me temps, puis ajoutent chacun 1, ils √©crivent
tous les deux 43 -> on perd une vente.

Une race condition, c‚Äôest comme deux personnes qui √©crivent sur le m√™me papier
en m√™me temps :

Si elles se coordonnent -> OK.
Si elles √©crivent en m√™me temps -> pas OK (les chiffres sont faux).

La solution dans un vrai programme :
	- Mutex (verrou)
	- S√©maphores
	- Verrou atomique (__sync_fetch_and_add, stdatomic.h) pour s‚Äôassurer
	qu‚Äôune seule personne √©crit √† la fois.

-----------------------------------CHATGPT---------------------------------

Explications Chatgpt : 

Comment les threads s‚Äôex√©cutent vraiment : 

- Sur un CPU √† un seul c≈ìur**, les threads ne s‚Äôex√©cutent pas litt√©ralement en 
m√™me temps -> l‚ÄôOS leur donne la main tour par tour (time slicing).
- Sur un CPU multi-c≈ìurs, plusieurs threads peuvent vraiment tourner en 
parall√®le (un par c≈ìur ou plus).

O√π est le pi√®ge ?

M√™me sur un seul c≈ìur, le probl√®me vient du fait que l‚ÄôOS peut interrompre un
thread √† n‚Äôimporte quel moment, y compris en plein milieu d‚Äôune op√©ration comme :

	-> g_drinks_served++;

Cette op√©ration semble √™tre une seule action en C, mais en r√©alit√© elle se fait
en plusieurs √©tapes (LOAD ‚Üí ADD ‚Üí STORE).
Si l‚ÄôOS coupe un thread apr√®s le LOAD, un autre thread peut modifier la variable,
puis le premier thread reprend avec une valeur p√©rim√©e -> race condition.

Pourquoi mutex & co existent

Sans protection : deux threads peuvent lire la m√™me valeur en m√™me temps, 
chacun ajouter 1, et perdre une mise √† jour.
Avec un mutex : on force un syst√®me de un seul √† la fois ¬ª sur la section
critique (l‚Äôendroit o√π la variable partag√©e est modifi√©e).

En gros, mutex = cl√© du comptoir Starbucks :

- Si un serveur veut mettre √† jour le registre, il prend la cl√©.
- Les autres attendent qu‚Äôil la rende.
- R√©sultat ‚Üí aucun √©crasement de valeur.

Les threads semblent travailler ¬´ en m√™me temps ¬ª gr√¢ce au multit√¢che, mais ils
peuvent aussi vraiment travailler en parall√®le sur plusieurs c≈ìurs.
Dans les deux cas, sans coordination, ils peuvent se marcher dessus -> d‚Äôo√π 
l‚Äôusage des mutex pour imposer un tour par tour s√©curis√©.

---------------------------------------------------------------------------

Pour voir ce probl√®me de race condition voici cet exemple suivant √† tester :
COMPILATION to see race
cc -fsanitize=thread test.c

---------------------------------EXEMPLE-----------------------------------

#include <stdio.h>
#include <pthread.h>

#define RACE_CONDITION 100000
// 0 by default
int g_drinks_served;
void *serve_drink(void *arg)
{
 int i;
 i = 0;
 while (i++ < RACE_CONDITION)
 {
    //These a 3 machine instructions, LOAD-ADD-STORE
  //as you saw in assembly, our waiter is slow
  g_drinks_served++; 
  
  /*
  Scheduler can switch programs whenever it wants
  1)LOAD    <-
  2)ADD     <-
  3)STORE   <-
    The RACE_CONDITION value is proportional to the Probability of it happening
  Try to run the code with different values
  */
 }
 return (NULL);
}
int main(void)
{
 pthread_t waiter1;
 pthread_t waiter2;
 
 pthread_create(&waiter1, NULL, serve_drink, NULL);
 pthread_create(&waiter2, NULL, serve_drink, NULL);
 pthread_join(waiter1, NULL);
 pthread_join(waiter2, NULL);
 printf("Total drinks served: %d\\n", g_drinks_served);
 return (0);
}

---------------------------------------------------------------------------

Mutex

Sans protection, deux threads peuvent :

	- Lire la m√™me valeur de la variable partag√©e (g_drinks_served).
	- Faire leur travail.
	- √âcrire la m√™me valeur mise √† jour -> une mise √† jour est perdue (race condition).

Face √† ce probl√®me de race condition les Mutex sont la solution.

√âvite les race conditions ‚Üí les donn√©es sont correctes m√™me avec plusieurs threads.

Mutex = MUTual EXclusion = verrou qui ne laisse passer qu‚Äôun seul thread √†
la fois dans la section critique (l‚Äôendroit o√π on modifie la ressource partag√©e).

Quand un thread verrouille le mutex (pthread_mutex_lock), les autres qui veulent
aussi l‚Äôutiliser attendent.
Quand il a fini, il lib√®re le verrou (pthread_mutex_unlock) -> un autre thread
peut entrer.

Fonctionnement dans le code ???

	- pthread_mutex_t mutex;
		le verrou global

	- pthread_mutex_lock(&mutex);
		prend la cl√© ‚Üí personne d‚Äôautre ne peut modifier la variable

	- g_drinks_served++;
		section critique : modif de la variable

	- pthread_mutex_unlock(&mutex);
		rend la cl√©

Cycle de vie du mutex
Initialisation : pthread_mutex_init(&mutex, NULL) (avant utilisation).
Utilisation : pthread_mutex_lock / pthread_mutex_unlock autour des sections critiques.
Destruction : pthread_mutex_destroy(&mutex) (√† la fin pour √©viter les fuites m√©moire).

Inconv√©nients -> Co√ªt en performance
	-> Chaque lock et unlock prend un peu de temps.
	-> Si un thread met longtemps √† lib√©rer le verrou, les autres doivent 
	attendre -> ralentissement du programme.

