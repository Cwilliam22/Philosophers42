
The dinning philosophers problem

Il y a un nombre N de philo dans le probl√®me.
Chaque philo poss√®de un ID (pour se rep√©rer).

3 √©tats :
	- pense
	- affam√©
	- mange 

R√©solution par s√©maphores

C'est un s√©maphore ???

	-> Un s√©maphore est une variable sp√©ciale utilis√©e en 
	programmation concurrente (notamment dans les syst√®mes 
	d‚Äôexploitation) pour g√©rer l'acc√®s √† des ressources 
	partag√©es par plusieurs processus ou threads, et √©viter 
	les conflits d‚Äôacc√®s (comme les conditions de course ou 
	les deadlocks).

Concr√®tement, un s√©maphore sert √† :

	- Coordonner l‚Äôutilisation d‚Äôune ressource limit√©e (par exemple, 
	un seul acc√®s √† une imprimante ou une fourchette dans le 
	probl√®me des philosophes).

	- Emp√™cher que plusieurs processus acc√®dent simultan√©ment √† une 
	ressource si cela peut causer un conflit.

	- Attendre qu‚Äôune ressource soit disponible.

Deux types de s√©maphores :

	- S√©maphore binaire (aussi appel√© mutex) :
		-> Ne prend que deux valeurs : 0 (occup√©) ou 1 (libre).
		-> Utilis√© pour l'exclusion mutuelle (acc√®s unique √† une 
			ressource √† la fois).
	- S√©maphore comptable (ou g√©n√©ral) :
		-> Peut prendre n‚Äôimporte quelle valeur enti√®re positive.
		-> Utilis√© quand plusieurs unit√©s d‚Äôune m√™me ressource 
			sont disponibles (ex : 3 fourchettes pour 5 philosophes).

Mutex explication : 

Les mutex (MUTual EXclusion) sont utilis√© pour prot√®ger des ressources/donn√©s 
contre un acces en simultan√©.

Exemple : Une seule clef peut rentrer dans la serrure √† l'instant T.

Sana mutex il y aurait des valeurs fausses, des bugs et pleins 
d'autres comportemeent imp√©visible.

Acces d'un thread ou d'un process par le biaie du mutex. Le thread ou le processus
modifie la ressource. Puis lib√®re le mutex pour qu'un autre thread puisse y acc√©der.
Prot√©ger la partie du code qui contient la ressource en utilisant un mutex.
Caract√©ristiques des mutex ???

Autres d√©finitions : 

	- Programmation concurrente : est une mani√®re de concevoir 
	des programmes o√π plusieurs t√¢ches peuvent s'ex√©cuter en m√™me 
	temps (ou de mani√®re entrelac√©e), souvent pour am√©liorer la 
	r√©activit√© ou les performances.

	- Thread : Un thread (ou fil d'ex√©cution) est une unit√© 
	d'ex√©cution l√©g√®re √† l‚Äôint√©rieur d‚Äôun programme. Un programme 
	peut avoir plusieurs threads qui s‚Äôex√©cutent en parall√®le.

	- Deadlock : Un deadlock est une situation o√π plusieurs 
	threads ou processus attendent ind√©finiment une ressource 
	d√©tenue par un autre, et aucun ne peut continuer. 


Thread
Utilise pour booster les performances d'un programme.
On repartit diffrentes taches entre differents thread pour etre plus efficace.
Un bon programme doit etre multi thread s'il veut etre rapide/performant/bon.

Les threads d‚Äôun m√™me processus partagent le m√™me espace m√©moire 
(contrairement aux processus, qui ont chacun leur propre m√©moire s√©par√©e).

Cela permet aux threads de s‚Äô√©changer des donn√©es facilement et d‚Äôacc√©der aux 
m√™mes variables/m√©moire sans co√ªt suppl√©mentaire (puisqu‚Äôils sont dans le m√™me 
espace m√©moire).

L‚ÄôIPC (communication entre processus) est donc beaucoup plus simple entre threads,
parce qu‚Äôils peuvent acc√©der directement aux m√™mes donn√©es.

Mais ! Le probl√®me compliqu√©, ce n‚Äôest pas de partager les donn√©es, c‚Äôest de
synchroniser correctement les acc√®s pour √©viter les conflits (conditions de
course, incoh√©rences, etc.).

Exemple :
Une personne pour tenir un restaurant est moins efficace qu'une equipe avec
chacun une tache assigne.

Un thread fonctionne comme un micro-process dans le process lui-meme.

Preparer la mise en place des thread dans notre programme en C :

#include <pthread.h>

Pour creer un thread :
	pthread_t my_thread;
		-> pthread_t est generalement un unsigned long
	int status = pthread_create(&my_thread, NULL, my_function, NULL);

Chaque thread a un identifiant unique.
Important pour manager les threads.
pthread_t represents the ID of a thread in UNIX-like systems.

---------------------------------EXEMPLE-----------------------------------
	#include <stdio.h>
	#include <pthread.h>

	void *print_thread_id(void *tid) 
	{
		printf("Thread ID: %lu\n", *(pthread_t *)tid);
		return NULL;
	}

	int main() {
		pthread_t thread1, thread2;
		pthread_create(&thread1, NULL, print_thread_id, &thread1);
		pthread_create(&thread2, NULL, print_thread_id, &thread2);

		pthread_join(thread1, NULL);
		pthread_join(thread2, NULL);

	}
---------------------------------------------------------------------------
Fonction pthread_create() :

int pthread_create(pthread_t *thread,
				   const pthread_attr_t *attr,
				   void *(*start_routine)(void *),
				   void *arg);

pthread_t *thread : pointeur vers un identifiant de thread
	-> l'ID du thread
const pthread_attr_t *attr : attributs du thread
	-> g√©n√©ralement NULL (valeurs par d√©faut)
void *(*start_routine)(void *) : pointeur vers la fonction du thread
	-> fonction qui sera ex√©cuter par le thread
void *arg : argument √† passer √† start_routine

√Ä quoi sert la fonction pthread_creat() ???
-> Sert √† cr√©er/d√©marrer un nouveau thread dans le programme

Fonction pthread_join() :

int pthread_join(pthread_t thread, void **retval);

pthread_t thread : identifiant du thread
void **retval : pointeur vers la valeur de retour du thread	

√Ä quoi sert la fonction pthread_join() ???
-> Attend que le thread cibl√© par thread finisse son ex√©cution
-> Optionnellement r√©cup√®re ce que le thread a retourn√© via return (un void *)
-> Bloque le thread appelant (souvent main()) jusqu‚Äô√† ce que l‚Äôautre thread soit termin√©
-> Nettoie automatiquement les ressources du thread (√©quivalent d‚Äôun free de thread)

Ces deux fonctions utilisent le ID pour manager ces thread.

On peut obtenir la l'ID en utilisant la fonction pthread_self().

Fonction pthread_self() :


---------------------------------EXEMPLE-----------------------------------

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

void *make_coffee(void *arg)
{
 printf("Making coffee...\n");
 sleep(2);
 printf("Coffee ready!\n");
 return (NULL);
}

void *make_pastry(void *arg)
{
 printf("Baking pastry...\n");
 sleep(3);
 printf("Pastry ready!\n");
 return (NULL);
}

int main(void)
{
 pthread_t coffee_thread;
 pthread_t pastry_thread;

 pthread_create(&coffee_thread, NULL, make_coffee, NULL);
 pthread_create(&pastry_thread, NULL, make_pastry, NULL);
 
 //Before handing the order to customer, i nees to WAIT both threads
 pthread_join(coffee_thread, NULL);
 pthread_join(pastry_thread, NULL);
 
 printf("\n\n\tThx for coming to Starbucks!\n"
	 "\there's the ‚òïÔ∏è 'n ü•ê\n\n\n");
 return (0);
}
---------------------------------------------------------------------------

Thread = une ¬´ mini-ex√©cution ¬ª √† l‚Äôint√©rieur d‚Äôun processus, qui peut tourner 
en parall√®le avec d‚Äôautres threads.
Chaque thread a une fonction d‚Äôentr√©e (comme un main pour lui tout seul).
	
	pthread_create(...) -> permet de cr√©er un thread.
	
	Arguments
	- Une variable de type pthread_t (l‚Äôidentifiant du thread),
	- Des options (souvent NULL),
	- La fonction que le thread ex√©cutera,
	- Un argument pour cette fonction (ou NULL).

	pthread_t = identifiant du thread (opaque, ne pas supposer que c‚Äôest un simple 
	unsigned long, m√™me si c‚Äôest souvent le cas).

	pthread_self() = permet √† un thread de conna√Ætre son propre ID.

	pthread_join(thread, NULL) = dit au programme : ¬´ Attend que ce thread finisse avant de continuer ¬ª.
		-> C‚Äôest l‚Äô√©quivalent de wait() mais pour les threads.
		-> Ce n‚Äôest pas un outil pour d√©finir l‚Äôordre d‚Äôex√©cution, juste un moyen 
		de synchroniser et s‚Äôassurer qu‚Äôun thread est termin√© avant de passer √† la suite.
		-> pthread_join() n‚Äôinfluence pas la priorit√© ni l‚Äôordre d‚Äôex√©cution des threads.
		-> outils de synchronisation

Dans l'exemple, comme les t√¢ches sont tr√®s simples et seulement diff√©renci√©es par un sleep, 
celui qui dort moins finira avant et donc son printf sortira plus t√¥t.

Mais dans un vrai programme, le temps de fin d√©pendra :

	- de la charge CPU
	- de l‚ÄôOS
	- du moment o√π le thread est planifi√©
	- du code qu‚Äôil ex√©cute

---------------------------------EXEMPLE-----------------------------------

#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int x = 42;
int main()
{
	pid_t pid = fork(); // Creates a new process
  // child
	if (0 == pid)
	{
		x++;
		printf("Child process: Value of x = %d\\n", x);
	}
  //parent
	else
	{
		wait(NULL); // Wait for child to finish
		printf("Parent process: Value of x = %d\\n", x);
	}
}
---------------------------------------------------------------------------

Resultat : 
Child process: Value of x = 43
Parent process: Value of x = 42


---------------------------------EXEMPLE-----------------------------------

#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

int x = 42;
void *thread_task(void *arg)
{
	++x;
	printf("Thread: Value of x = %d\\n", x);
	return NULL;
}
int main()
{
	pthread_t thread1, thread2;
	pthread_create(&thread1, NULL, thread_task, NULL);
	pthread_create(&thread2, NULL, thread_task, NULL);
	pthread_join(thread1, NULL);
	pthread_join(thread2, NULL);
	return 0;
}

---------------------------------------------------------------------------

Resultat :
Thread: Value of x = 43
Thread: Value of x = 44

Deux exemples qui montre la difference entre les process et les threads.
Les process fonctionenent chacun de leur cote (leur propre data, leur propre memoire, etc).
Les thread partage tout !!!

Sur la memoire :
	(Processus)
		- A sa propre m√©moire isol√©e (code, donn√©es, pile).
		- Les variables globales ne sont pas partag√©es entre processus.
		- Si un processus fils modifie une variable, le p√®re ne le voit pas.
		- Exemple : fork() ‚Üí le p√®re et le fils ont chacun leur copie de x.

	(Threads)
		- Partagent le m√™me espace m√©moire dans un processus.
		- Les variables globales sont communes √† tous les threads.
		- Si un thread modifie x, tous les autres voient le changement.

Sur l'ID et le PID:
	Chaque process a un PID unique.
	Tout les threads dans un process partagent le meme PID.
		-> Chaque process possede aussi son propre ID.

---------------------------------EXEMPLE-----------------------------------

#include <pthread.h>
#include <unistd.h>
#include <stdio.h>

// This function represents the routine (task) our workers (threads) will execute.
void *worker_routine(void *arg)
{
	// All workers (threads) inside the factory (process) will print the same address (PID)
	printf("Worker ID->%lu: My factory's address (PID) is %d\\n", pthread_self(), getpid());
	return (NULL);
}
int main(void)
{
	pthread_t worker1;
	pthread_t worker2;
	// Let's create two workers (threads) in the same factory (process).
	// Hiring (creating) the first worker.
	if (pthread_create(&worker1, NULL, worker_routine, NULL) != 0)
		return (1);
	// Hiring (creating) the second worker.
	if (pthread_create(&worker2, NULL, worker_routine, NULL) != 0)
		return (2);
	// Wait for both workers to finish their shift (tasks).
	pthread_join(worker1, NULL);
	pthread_join(worker2, NULL);
	return (0);
}

---------------------------------------------------------------------------

Sur la communication :

	(Processus)
		- N√©cessite des m√©canismes sp√©ciaux (IPC) : pipes, sockets, m√©moire partag√©e.
	(Threads)
		- Communication simple car m√™me m√©moire.
		- Risque de corruption de donn√©es si acc√®s simultan√© non contr√¥l√© ‚Üí mutex/semaphores obligatoires pour √©viter les race conditions.

